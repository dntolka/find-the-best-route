import java.util.*;
import java.text.DecimalFormat;
import java.io.FileWriter;   // Import the FileWriter class
import java.io.IOException;  // Import the IOException class to handle errors

public class IDAstar{

    public LinkedList<Double> pred_cost = new LinkedList<>();
    public LinkedList<Double> actual_cost = new LinkedList<>();

    public Node idastar_search(Graph graph, int day) 
    {
        for (Map.Entry<String,Node> entry : graph.nodes.entrySet()){
          entry.getValue().init();
        }
  
        UCS ucs = new UCS();
        ucs.ucs_route(graph, graph.nodes.get(graph.start), graph.nodes.get(graph.goal) , day);
		LinkedList<Node> path2 = ucs.getPath(graph.nodes.get(graph.goal));
        double threshold = path2.getLast().pathCost; /* Find initial threshold */

        LinkedList<Node> path = new LinkedList<>();
        path.add(0, graph.nodes.get(graph.start));  /* root of path the source */

        double new_threshold;

        do {
            new_threshold = recur_search(graph , ucs, path, 0, threshold, day);

            if (new_threshold == 0.0){  /* The goal node is found and path contains optimal path */
                return path.get(path.size() - 1);
            }

            threshold = new_threshold; /* new threshold */

        } while (threshold != Double.MAX_VALUE); /* No node was found with a higher f than threshold. Goal node does not exist */

        return null;
    }

    private double recur_search(Graph graph,UCS ucs, LinkedList<Node> path, double graphCost, double currentFBound, int day) {

        Node currentNode = path.get(path.size() - 1); /* G, H, and F of Current Node */

        ucs.ucs_route(graph, currentNode, graph.nodes.get(graph.goal) , day);
		LinkedList<Node> path2 = ucs.getPath(graph.nodes.get(graph.goal));
        double temp_h = path2.getLast().pathCost;

        currentNode.setH(temp_h);
        currentNode.setG(graphCost);
        currentNode.setF(graphCost + currentNode.getH());
       
        if (currentNode.getF() > currentFBound)  /* currents node's F is larger than current Bound */
            return currentNode.getF();

        if (currentNode.name.equals(graph.goal))
            return 0;

        double minFFound = Double.MAX_VALUE;

        LinkedList<Node> children = currentNode.getAdj(currentNode);
       
        for (Node child : children) { /* Expand search every adjacent */

            if (!path.contains(child)) { /* Child is not already on the search path */

                path.add(child); /* add child to path and search down the path */
                Roads road = child.find_road(child , currentNode);
                double minFOverBound = recur_search(graph, ucs, path, currentNode.getG() + road.cost, currentFBound, day);

                if (minFOverBound == 0.0){
                    currentNode.setChild_fmin(child); 
                     return 0.0;
                }  

                /* Keep the smallest F Found Over Bound generated by each child's search path */
                if (minFOverBound < minFFound){
                    minFFound = minFOverBound;
                    currentNode.setChild_fmin(child); 
                }
       
                path.remove(path.size() - 1); /* remove child from search path before exploring next */
            }
        }

        return minFFound;
    }

    public LinkedList<Node> getPath(Graph graph , Node n , int day)
    {
        LinkedList<Node> queue = new LinkedList<>();

        while(n != null){
            queue.add(n);
          
            if(n.getChild_fmin() != null){
                Roads r = n.find_road(n, n.getChild_fmin());
                
                double c = graph.check_traffic(graph.predicted_traffic, day, r);
                pred_cost.add(c);

                c = graph.check_traffic_real(graph.actual_traffic, day, r);
                actual_cost.add(c);
            }
            n = n.getChild_fmin();
        }
        
        return queue;
    }

    public double print_ida_star(FileWriter myWriter, Graph graph , long time, LinkedList<Node> path)
    {
        double pred_cost_path=0 , actual_cost_path=0;
        
        try {
            System.out.println("IDA*:");
            myWriter.write("IDA*:\n");
            System.out.println("	Visited Nodes number: "+ path.size() );
            myWriter.write("	Visited Nodes number: "+ path.size() +"\n");
            System.out.println("	Execution Time: "+time+" ns");
            myWriter.write("	Execution Time: "+time+" ns\n");
            
            System.out.print("	Path: ");
            myWriter.write("	Path: ");

            for(int i =0; i<=this.pred_cost.size()-1; i++){    
                pred_cost_path += this.pred_cost.get(i);
                actual_cost_path += this.actual_cost.get(i);
                
                if(i==this.pred_cost.size()-1){
                    System.out.print(path.get(i).name + "(" +  this.pred_cost.get(i) + ")" + " -> " + path.getLast().name);
                    myWriter.write(path.get(i).name + "(" +  this.pred_cost.get(i) + ")" + " -> " + path.getLast().name);
                }else{
                    myWriter.write(path.get(i).name + "(" +  this.pred_cost.get(i) + ")" + " -> ");
                    System.out.print(path.get(i).name + "(" +  this.pred_cost.get(i) + ")" + " -> ");
                }
            }
            myWriter.write("\n");
            System.out.print("\n");

            System.out.println("        Predicted Cost: "+Double.parseDouble(new DecimalFormat("#.000").format(pred_cost_path)));
            myWriter.write("    Predicted Cost: "+Double.parseDouble(new DecimalFormat("#.000").format(pred_cost_path))+"\n");

            System.out.println("        Real Cost: "+Double.parseDouble(new DecimalFormat("#.000").format(actual_cost_path))+"\n");
            myWriter.write("    Real Cost: "+Double.parseDouble(new DecimalFormat("#.000").format(actual_cost_path)));

        } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }

        path.getLast().pathCost = pred_cost_path;
        return actual_cost_path;
    }

}